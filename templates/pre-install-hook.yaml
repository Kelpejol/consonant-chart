{{/*
Pre-Install Hook - Enhanced Cluster Registration
================================================
Registers cluster with backend and creates credentials
Now with proper JSON validation and error handling
*/}}

{{- if not .Values.backend.credentials.existingSecret }}

{{/*
=============================================
REGISTRATION SCRIPT CONFIGMAP
=============================================
*/}}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "consonant-relayer.fullname" . }}-register-script
  namespace: {{ include "consonant-relayer.namespace" . }}
  labels:
    {{- include "consonant-relayer.labels" . | nindent 4 }}
    app.kubernetes.io/component: registration
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-weight: "-15"
    helm.sh/hook-delete-policy: before-hook-creation
data:
  register.sh: |
    #!/bin/sh
    # Enhanced cluster registration script
    # Includes JSON validation and better error handling
    
    set -e
    
    # ====================================
    # Configuration
    # ====================================
    CLUSTER_NAME="${CLUSTER_NAME}"
    NAMESPACE="${NAMESPACE}"
    BACKEND_URL="${BACKEND_URL}"
    CLOUDFLARE_ENABLED="${CLOUDFLARE_ENABLED}"
    SECRET_NAME="{{ include "consonant-relayer.clusterSecretName" . }}"
    TIMEOUT=300
    
    # ====================================
    # Header
    # ====================================
    echo "=============================================="
    echo "  Consonant Cluster Registration"
    echo "  Version: {{ .Chart.Version }}"
    echo "=============================================="
    echo ""
    echo "Configuration:"
    echo "  Cluster Name:    ${CLUSTER_NAME}"
    echo "  Namespace:       ${NAMESPACE}"
    echo "  Backend URL:     ${BACKEND_URL}"
    echo "  Cloudflare:      ${CLOUDFLARE_ENABLED}"
    echo "  Secret Name:     ${SECRET_NAME}"
    echo ""
    
    # ====================================
    # Install jq for JSON parsing
    # ====================================
    echo "üì¶ Installing dependencies..."
    if ! command -v jq &>/dev/null; then
      apk add --no-cache jq 2>/dev/null || {
        echo "‚ö†Ô∏è  Could not install jq, using fallback parser"
        USE_FALLBACK_PARSER=true
      }
    fi
    echo ""
    
    # ====================================
    # Determine Connection Method
    # ====================================
    if [ "${CLOUDFLARE_ENABLED}" = "true" ]; then
      echo "üîí Using Cloudflare Tunnel"
      REGISTER_URL="http://localhost:8080/api/v1/clusters"
      
      # Wait for tunnel
      echo "‚è≥ Waiting for tunnel (max ${TIMEOUT}s)..."
      elapsed=0
      interval=2
      
      while [ $elapsed -lt $TIMEOUT ]; do
        if nc -z localhost 8080 2>/dev/null; then
          echo "‚úÖ Tunnel is ready!"
          break
        fi
        
        if [ $elapsed -ge $TIMEOUT ]; then
          echo "‚ùå ERROR: Tunnel did not start within ${TIMEOUT}s"
          echo ""
          echo "Debug steps:"
          echo "  1. Check cloudflared sidecar logs"
          echo "  2. Verify tunnel token is correct"
          echo "  3. Check Cloudflare dashboard for tunnel status"
          exit 1
        fi
        
        sleep $interval
        elapsed=$((elapsed + interval))
      done
    else
      echo "üåê Using direct connection"
      REGISTER_URL="${BACKEND_URL}/api/v1/clusters"
    fi
    echo ""
    
    # ====================================
    # Prepare Registration Payload
    # ====================================
    PAYLOAD=$(cat <<EOF
    {
      "name": "${CLUSTER_NAME}",
      "namespace": "${NAMESPACE}",
      "metadata": {
        "chartVersion": "{{ .Chart.Version }}",
        "installTime": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "helmRelease": "{{ .Release.Name }}",
        {{- if .Values.cluster.region }}
        "region": "{{ .Values.cluster.region }}",
        {{- end }}
        {{- if .Values.cluster.environment }}
        "environment": "{{ .Values.cluster.environment }}",
        {{- end }}
        "kubernetes": {
          "version": "{{ .Capabilities.KubeVersion.Version }}"
        }
      }
    }
    EOF
    )
    
    echo "üìù Registration payload:"
    echo "$PAYLOAD" | jq '.' 2>/dev/null || echo "$PAYLOAD"
    echo ""
    
    # ====================================
    # Register with Backend
    # ====================================
    echo "üöÄ Registering cluster with backend..."
    echo "   POST ${REGISTER_URL}"
    
    RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${REGISTER_URL}" \
      -H "Content-Type: application/json" \
      -H "Accept: application/json" \
      -H "User-Agent: consonant-helm/{{ .Chart.Version }}" \
      -d "$PAYLOAD" \
      --max-time 30 \
      --retry 3 \
      --retry-delay 2 \
      --connect-timeout 10 \
      --retry-connrefused)
    
    curl_exit=$?
    if [ $curl_exit -ne 0 ]; then
      echo "‚ùå ERROR: curl failed (exit code: $curl_exit)"
      echo ""
      case $curl_exit in
        6) echo "Could not resolve host" ;;
        7) echo "Failed to connect to host" ;;
        28) echo "Connection timeout" ;;
        *) echo "Unknown error" ;;
      esac
      echo ""
      echo "Troubleshooting:"
      echo "  1. Verify backend is running:"
      echo "     curl ${BACKEND_URL}/health"
      echo "  2. Check network connectivity from cluster"
      {{- if .Values.cloudflare.enabled }}
      echo "  3. Verify Cloudflare tunnel configuration"
      {{- end }}
      exit 1
    fi
    
    # ====================================
    # Parse Response
    # ====================================
    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
    BODY=$(echo "$RESPONSE" | head -n-1)
    
    echo "   HTTP Status: ${HTTP_CODE}"
    echo ""
    
    # Check HTTP status
    if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "201" ]; then
      echo "‚ùå ERROR: Registration failed"
      echo ""
      echo "HTTP ${HTTP_CODE}"
      echo ""
      echo "Response:"
      echo "$BODY" | jq '.' 2>/dev/null || echo "$BODY"
      echo ""
      
      case "$HTTP_CODE" in
        400)
          echo "Bad Request:"
          echo "  - Cluster name may be invalid"
          echo "  - Check payload format"
          ;;
        401|403)
          echo "Authentication Error:"
          echo "  - Backend may require authentication"
          echo "  - Check API configuration"
          ;;
        404)
          echo "Not Found:"
          echo "  - Endpoint may not exist"
          echo "  - Expected: POST /api/v1/clusters"
          ;;
        409)
          echo "Conflict:"
          echo "  - Cluster name already exists"
          echo "  - Use a different cluster name"
          ;;
        500|502|503)
          echo "Server Error:"
          echo "  - Backend may be down"
          echo "  - Check backend logs"
          ;;
      esac
      
      exit 1
    fi
    
    # ====================================
    # Validate and Parse JSON Response
    # ====================================
    echo "üìä Validating response..."
    
    # Validate JSON format
    if command -v jq &>/dev/null; then
      if ! echo "$BODY" | jq empty 2>/dev/null; then
        echo "‚ùå ERROR: Invalid JSON response"
        echo ""
        echo "Response:"
        echo "$BODY"
        exit 1
      fi
      
      # Extract with jq
      CLUSTER_ID=$(echo "$BODY" | jq -r '.id // empty')
      CLUSTER_TOKEN=$(echo "$BODY" | jq -r '.token // empty')
      
      # Additional validation
      if [ -z "$CLUSTER_ID" ] || [ -z "$CLUSTER_TOKEN" ]; then
        echo "‚ùå ERROR: Response missing required fields"
        echo ""
        echo "Expected: {\"id\": \"...\", \"token\": \"...\"}"
        echo "Received:"
        echo "$BODY" | jq '.'
        exit 1
      fi
      
      # Validate field formats
      if ! echo "$CLUSTER_ID" | grep -qE '^[a-zA-Z0-9_-]+$'; then
        echo "‚ùå ERROR: Invalid cluster ID format"
        echo "   Cluster ID: $CLUSTER_ID"
        exit 1
      fi
      
      if [ ${#CLUSTER_TOKEN} -lt 32 ]; then
        echo "‚ùå ERROR: Cluster token too short"
        echo "   Token length: ${#CLUSTER_TOKEN}"
        exit 1
      fi
      
    else
      # Fallback parser (less robust)
      echo "‚ö†Ô∏è  Using fallback JSON parser"
      
      CLUSTER_ID=$(echo "$BODY" | sed -n 's/.*"id"\s*:\s*"\([^"]*\)".*/\1/p')
      CLUSTER_TOKEN=$(echo "$BODY" | sed -n 's/.*"token"\s*:\s*"\([^"]*\)".*/\1/p')
      
      if [ -z "$CLUSTER_ID" ] || [ -z "$CLUSTER_TOKEN" ]; then
        echo "‚ùå ERROR: Could not parse credentials"
        echo ""
        echo "Response:"
        echo "$BODY"
        exit 1
      fi
    fi
    
    echo "‚úÖ Credentials validated"
    echo "   Cluster ID: ${CLUSTER_ID}"
    echo "   Token length: ${#CLUSTER_TOKEN}"
    echo ""
    
    # ====================================
    # Create Kubernetes Secret
    # ====================================
    echo "üîê Creating Kubernetes secret..."
    
    kubectl create secret generic "${SECRET_NAME}" \
      --from-literal=clusterId="${CLUSTER_ID}" \
      --from-literal=clusterToken="${CLUSTER_TOKEN}" \
      --from-literal=clusterName="${CLUSTER_NAME}" \
      --namespace="${NAMESPACE}" \
      --dry-run=client -o yaml | kubectl apply -f -
    
    if [ $? -ne 0 ]; then
      echo "‚ùå ERROR: Failed to create secret"
      echo ""
      echo "Check RBAC permissions:"
      echo "  kubectl auth can-i create secrets -n ${NAMESPACE}"
      exit 1
    fi
    
    echo "‚úÖ Secret created: ${SECRET_NAME}"
    echo ""
    
    # ====================================
    # Verify Secret
    # ====================================
    echo "üîç Verifying secret..."
    
    if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" &>/dev/null; then
      echo "‚úÖ Secret verified"
      
      # Verify keys exist
      if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" \
          -o jsonpath='{.data.clusterId}' | base64 -d &>/dev/null && \
         kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" \
          -o jsonpath='{.data.clusterToken}' | base64 -d &>/dev/null; then
        echo "‚úÖ All keys present"
      else
        echo "‚ùå ERROR: Secret missing keys"
        exit 1
      fi
    else
      echo "‚ùå ERROR: Secret not found after creation"
      exit 1
    fi
    echo ""
    
    # ====================================
    # Success
    # ====================================
    echo "=============================================="
    echo "  ‚úÖ Registration Complete"
    echo "=============================================="
    echo ""
    echo "Summary:"
    echo "  Cluster ID:    ${CLUSTER_ID}"
    echo "  Secret:        ${SECRET_NAME}"
    echo "  Namespace:     ${NAMESPACE}"
    echo ""
    echo "Next steps:"
    echo "  ‚Üí Relayer will connect using these credentials"
    echo "  ‚Üí View in UI: ${BACKEND_URL}/clusters/${CLUSTER_ID}"
    echo ""

{{/*
=============================================
REGISTRATION JOB
=============================================
*/}}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "consonant-relayer.fullname" . }}-register
  namespace: {{ include "consonant-relayer.namespace" . }}
  labels:
    {{- include "consonant-relayer.labels" . | nindent 4 }}
    app.kubernetes.io/component: registration
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-weight: "-10"
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
spec:
  ttlSecondsAfterFinished: {{ .Values.hooks.registration.ttlSecondsAfterFinished }}
  backoffLimit: {{ .Values.hooks.registration.backoffLimit }}
  
  template:
    metadata:
      labels:
        {{- include "consonant-relayer.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: registration
      annotations:
        sidecar.istio.io/inject: "false"
        linkerd.io/inject: disabled
    
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "consonant-relayer.fullname" . }}-hook
      
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        fsGroup: 65534
        seccompProfile:
          type: RuntimeDefault
      
      {{- if .Values.cloudflare.enabled }}
      {{/* Cloudflared sidecar */}}
      containers:
      - name: cloudflared
        image: {{ include "consonant-relayer.cloudflaredImage" . }}
        imagePullPolicy: {{ .Values.cloudflare.sidecar.image.pullPolicy }}
        args:
          - tunnel
          - --no-autoupdate
          - --protocol={{ .Values.cloudflare.sidecar.protocol }}
          - --loglevel=info
          - run
          - --token=$(TUNNEL_TOKEN)
        env:
        - name: TUNNEL_TOKEN
          valueFrom:
            secretKeyRef:
              name: {{ include "consonant-relayer.tunnelSecretName" . }}
              key: token
        ports:
        - name: http
          containerPort: 8080
        - name: metrics
          containerPort: 2000
        resources:
          {{- toYaml .Values.cloudflare.sidecar.resources | nindent 10 }}
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop: [ALL]
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 65532
      {{- end }}
      
      {{/* Registration container */}}
      - name: register
        image: {{ include "consonant-relayer.kubectlImage" . }}
        imagePullPolicy: {{ .Values.hooks.registration.kubectlImage.pullPolicy }}
        command:
          - /bin/sh
          - /scripts/register.sh
        env:
        - name: CLUSTER_NAME
          value: {{ .Values.cluster.name | quote }}
        - name: NAMESPACE
          value: {{ include "consonant-relayer.namespace" . | quote }}
        - name: BACKEND_URL
          value: {{ .Values.backend.url | quote }}
        - name: CLOUDFLARE_ENABLED
          value: {{ .Values.cloudflare.enabled | quote }}
        volumeMounts:
        - name: scripts
          mountPath: /scripts
          readOnly: true
        - name: tmp
          mountPath: /tmp
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop: [ALL]
          readOnlyRootFilesystem: false  # Need to install jq
          runAsNonRoot: true
          runAsUser: 65534
        resources:
          {{- toYaml .Values.hooks.registration.resources | nindent 10 }}
      
      volumes:
      - name: scripts
        configMap:
          name: {{ include "consonant-relayer.fullname" . }}-register-script
          defaultMode: 0755
      - name: tmp
        emptyDir: {}

{{- end }}