{{/*
Pre-Install Hook - Cluster Registration with Bearer Token
==========================================================
Registers cluster with backend using bearer token authentication
Returns cluster_id and cluster_token which are stored as K8s secret
Bearer token is NOT stored in cluster
*/}}

{{- if not .Values.backend.credentials.existingSecret }}

{{/*
=============================================
REGISTRATION SCRIPT CONFIGMAP
=============================================
*/}}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "consonant-relayer.fullname" . }}-register-script
  namespace: {{ include "consonant-relayer.namespace" . }}
  labels:
    {{- include "consonant-relayer.labels" . | nindent 4 }}
    app.kubernetes.io/component: registration
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-weight: "-15"
    helm.sh/hook-delete-policy: before-hook-creation
data:
  register.sh: |
    #!/bin/sh
     # Consonant Cluster Registration Script
     # Uses bearer token for authentication (ONE-TIME USE)
    # Returns cluster_id and cluster_token for runtime use
    
    set -e
    
    # ====================================
    # Configuration
    # ====================================
    CLUSTER_NAME="${CLUSTER_NAME}"
    NAMESPACE="${NAMESPACE}"
    BACKEND_URL="${BACKEND_URL}"
    SECRET_NAME="{{ include "consonant-relayer.clusterSecretName" . }}"
    TIMEOUT=300
    
    # ====================================
    # Header
    # ====================================
    echo "=============================================="
    echo "  Consonant Cluster Registration"
    echo "  Version: {{ .Chart.Version }}"
    echo "=============================================="
    echo ""
    echo "Configuration:"
    echo "  Cluster Name:    ${CLUSTER_NAME}"
    echo "  Namespace:       ${NAMESPACE}"
    echo "  Backend URL:     ${BACKEND_URL}"
    echo "  Secret Name:     ${SECRET_NAME}"
    echo ""
    
    # ====================================
    # Install jq for JSON parsing
    # ====================================
    echo "üì¶ Installing dependencies..."
    if ! command -v jq &>/dev/null; then
      apk add --no-cache jq 2>/dev/null || {
        echo "‚ö†Ô∏è  Could not install jq, using fallback parser"
        USE_FALLBACK_PARSER=true
      }
    fi
    echo ""
    
    
    # ====================================
    # Prepare Registration Payload
    # ====================================
    PAYLOAD=$(cat <<EOF
    {
      "name": "${CLUSTER_NAME}",
      "namespace": "${NAMESPACE}",
      "metadata": {
        "chartVersion": "{{ .Chart.Version }}",
        "installTime": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "helmRelease": "{{ .Release.Name }}",
        {{- if .Values.cluster.region }}
        "region": "{{ .Values.cluster.region }}",
        {{- end }}
        {{- if .Values.cluster.environment }}
        "environment": "{{ .Values.cluster.environment }}",
        {{- end }}
        "kubernetes": {
          "version": "{{ .Capabilities.KubeVersion.Version }}"
        }
      }
    }
    EOF
    )
    
    echo "üìù Registration payload:"
    echo "$PAYLOAD" | jq '.' 2>/dev/null || echo "$PAYLOAD"
    echo ""
    
    # ====================================
    # Register with Backend
    # ====================================
    echo "üöÄ Registering cluster with backend..."
    echo "   POST ${REGISTER_URL}"
    
    # Make HTTP request with bearer token authentication
    RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${REGISTER_URL}" \
      -H "Content-Type: application/json" \
      -H "Accept: application/json" \
      -H "Authorization: Bearer ${BEARER_TOKEN}" \
      -H "User-Agent: consonant-helm/{{ .Chart.Version }}" \
      -d "$PAYLOAD" \
      --max-time 30 \
      --retry 3 \
      --retry-delay 2 \
      --connect-timeout 10 \
      --retry-connrefused \
      {{- if not .Values.backend.tlsVerify }}
      --insecure \
      {{- end }}
      2>&1)
    
    curl_exit=$?
    if [ $curl_exit -ne 0 ]; then
      echo "‚ùå ERROR: curl failed (exit code: $curl_exit)"
      echo ""
      case $curl_exit in
        6) echo "Could not resolve host" ;;
        7) echo "Failed to connect to host" ;;
        28) echo "Connection timeout" ;;
        35) echo "SSL/TLS handshake failed" ;;
        *) echo "Unknown error" ;;
      esac
      echo ""
      echo "Troubleshooting:"
      echo "  1. Verify backend is running:"
      echo "     curl ${BACKEND_URL}/health"
      echo "  2. Check network connectivity from cluster"
      echo "  3. Verify bearer token is correct"
      exit 1
    fi
    
    # ====================================
    # Parse Response
    # ====================================
    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
    BODY=$(echo "$RESPONSE" | head -n-1)
    
    echo "   HTTP Status: ${HTTP_CODE}"
    echo ""
    
    # Check HTTP status
    if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "201" ]; then
      echo "‚ùå ERROR: Registration failed"
      echo ""
      echo "HTTP ${HTTP_CODE}"
      echo ""
      echo "Response:"
      echo "$BODY" | jq '.' 2>/dev/null || echo "$BODY"
      echo ""
      
      case "$HTTP_CODE" in
        400)
          echo "Bad Request:"
          echo "  - Cluster name may be invalid"
          echo "  - Check payload format"
          ;;
        401)
          echo "Authentication Error:"
          echo "  - Bearer token is invalid or expired"
          echo "  - Check auth.bearerToken value"
          ;;
        403)
          echo "Authorization Error:"
          echo "  - Token doesn't have permission to register clusters"
          ;;
        404)
          echo "Not Found:"
          echo "  - Endpoint may not exist"
          echo "  - Expected: POST /api/v1/clusters"
          ;;
        409)
          echo "Conflict:"
          echo "  - Cluster name already exists"
          echo "  - Use a different cluster name"
          ;;
        500|502|503)
          echo "Server Error:"
          echo "  - Backend may be down"
          echo "  - Check backend logs"
          ;;
      esac
      
      exit 1
    fi
    
    # ====================================
    # Validate and Parse JSON Response
    # ====================================
    echo "üìä Validating response..."
    
    # Validate JSON format
    if command -v jq &>/dev/null; then
      if ! echo "$BODY" | jq empty 2>/dev/null; then
        echo "‚ùå ERROR: Invalid JSON response"
        echo ""
        echo "Response:"
        echo "$BODY"
        exit 1
      fi
      
      # Extract with jq
      CLUSTER_ID=$(echo "$BODY" | jq -r '.id // empty')
      CLUSTER_TOKEN=$(echo "$BODY" | jq -r '.token // empty')
      
      # Additional validation
      if [ -z "$CLUSTER_ID" ] || [ -z "$CLUSTER_TOKEN" ]; then
        echo "‚ùå ERROR: Response missing required fields"
        echo ""
        echo "Expected: {\"id\": \"...\", \"token\": \"...\"}"
        echo "Received:"
        echo "$BODY" | jq '.'
        exit 1
      fi
      
      # Validate field formats
      if ! echo "$CLUSTER_ID" | grep -qE '^[a-zA-Z0-9_-]+$'; then
        echo "‚ùå ERROR: Invalid cluster ID format"
        echo "   Cluster ID: $CLUSTER_ID"
        exit 1
      fi
      
      if [ ${#CLUSTER_TOKEN} -lt 32 ]; then
        echo "‚ùå ERROR: Cluster token too short"
        echo "   Token length: ${#CLUSTER_TOKEN}"
        exit 1
      fi
      
    else
      # Fallback parser (less robust)
      echo "‚ö†Ô∏è  Using fallback JSON parser"
      
      CLUSTER_ID=$(echo "$BODY" | sed -n 's/.*"id"\s*:\s*"\([^"]*\)".*/\1/p')
      CLUSTER_TOKEN=$(echo "$BODY" | sed -n 's/.*"token"\s*:\s*"\([^"]*\)".*/\1/p')
      
      if [ -z "$CLUSTER_ID" ] || [ -z "$CLUSTER_TOKEN" ]; then
        echo "‚ùå ERROR: Could not parse credentials"
        echo ""
        echo "Response:"
        echo "$BODY"
        exit 1
      fi
    fi
    
    echo "‚úÖ Credentials validated"
    echo "   Cluster ID: ${CLUSTER_ID}"
    echo "   Token length: ${#CLUSTER_TOKEN}"
    echo ""
    
    # ====================================
    # Create Kubernetes Secret
    # ====================================
    echo "üîê Creating Kubernetes secret..."
    
    kubectl create secret generic "${SECRET_NAME}" \
      --from-literal=clusterId="${CLUSTER_ID}" \
      --from-literal=clusterToken="${CLUSTER_TOKEN}" \
      --from-literal=clusterName="${CLUSTER_NAME}" \
      --namespace="${NAMESPACE}" \
      --dry-run=client -o yaml | kubectl apply -f -
    
    if [ $? -ne 0 ]; then
      echo "‚ùå ERROR: Failed to create secret"
      echo ""
      echo "Check RBAC permissions:"
      echo "  kubectl auth can-i create secrets -n ${NAMESPACE}"
      exit 1
    fi
    
    echo "‚úÖ Secret created: ${SECRET_NAME}"
    echo ""
    
    # ====================================
    # Verify Secret
    # ====================================
    echo "üîç Verifying secret..."
    
    if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" &>/dev/null; then
      echo "‚úÖ Secret verified"
      
      # Verify keys exist
      if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" \
          -o jsonpath='{.data.clusterId}' | base64 -d &>/dev/null && \
         kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" \
          -o jsonpath='{.data.clusterToken}' | base64 -d &>/dev/null; then
        echo "‚úÖ All keys present"
      else
        echo "‚ùå ERROR: Secret missing keys"
        exit 1
      fi
    else
      echo "‚ùå ERROR: Secret not found after creation"
      exit 1
    fi
    echo ""
    
    # ====================================
    # Success
    # ====================================
    echo "=============================================="
    echo "  ‚úÖ Registration Complete"
    echo "=============================================="
    echo ""
    echo "Summary:"
    echo "  Cluster ID:    ${CLUSTER_ID}"
    echo "  Secret Name:   ${SECRET_NAME}"
    echo "  Namespace:     ${NAMESPACE}"
    echo ""
    echo "Security Note:"
    echo "  ‚úì cluster_id and cluster_token stored in secret"
    echo "  ‚úì Bearer token NOT stored (one-time use only)"
    echo ""
    echo "Next:"
    echo "  ‚Üí Relayer will connect using cluster credentials"
    echo "  ‚Üí View cluster in backend UI"
    echo ""
{{/*
=============================================
REGISTRATION JOB
=============================================
*/}}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "consonant-relayer.fullname" . }}-register
  namespace: {{ include "consonant-relayer.namespace" . }}
  labels:
    {{- include "consonant-relayer.labels" . | nindent 4 }}
    app.kubernetes.io/component: registration
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-weight: "-10"
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
spec:
  ttlSecondsAfterFinished: {{ .Values.hooks.registration.ttlSecondsAfterFinished }}
  backoffLimit: {{ .Values.hooks.registration.backoffLimit }}
  
  template:
    metadata:
      labels:
        {{- include "consonant-relayer.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: registration
      annotations:
        sidecar.istio.io/inject: "false"
        linkerd.io/inject: disabled
    
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "consonant-relayer.fullname" . }}-hook
      
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        fsGroup: 65534
        seccompProfile:
          type: RuntimeDefault
    
    containers:  
      {{/* Registration container */}}
      - name: register
        image: {{ include "consonant-relayer.kubectlImage" . }}
        imagePullPolicy: {{ .Values.hooks.registration.kubectlImage.pullPolicy }}
        command:
          - /bin/sh
          - /scripts/register.sh
        env:
        - name: CLUSTER_NAME
          value: {{ .Values.cluster.name | quote }}
        - name: NAMESPACE
          value: {{ include "consonant-relayer.namespace" . | quote }}
        - name: BACKEND_URL
          value: {{ .Values.backend.url | quote }}
      # CRITICAL: Bearer token from values (one-time use, NOT stored)
        - name: BEARER_TOKEN
          {{- if .Values.auth.existingSecret.enabled }}
          valueFrom:
            secretKeyRef:
              name: {{ .Values.auth.existingSecret.name }}
              key: {{ .Values.auth.existingSecret.key }}
          {{- else }}
          value: {{ required "auth.bearerToken is required" .Values.auth.bearerToken | quote }}
          {{- end }}
        
        volumeMounts:
        - name: scripts
          mountPath: /scripts
          readOnly: true
        - name: tmp
          mountPath: /tmp
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop: [ALL]
          readOnlyRootFilesystem: false  # Need to install jq
          runAsNonRoot: true
          runAsUser: 65534
        resources:
          {{- toYaml .Values.hooks.registration.resources | nindent 10 }}
      
        volumes:
      - name: scripts
        configMap:
          name: {{ include "consonant-relayer.fullname" . }}-register-script
          defaultMode: 0755
      - name: tmp
        emptyDir: {}

{{- end }}